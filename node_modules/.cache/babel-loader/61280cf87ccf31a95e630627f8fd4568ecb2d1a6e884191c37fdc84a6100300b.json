{"ast":null,"code":"\"use strict\";\n\nvar __assign = this && this.__assign || function () {\n  __assign = Object.assign || function (t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n      s = arguments[i];\n      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n    }\n    return t;\n  };\n  return __assign.apply(this, arguments);\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.attachSharedListeners = void 0;\nvar globals_1 = require(\"./globals\");\nvar constants_1 = require(\"./constants\");\nvar manage_subscribers_1 = require(\"./manage-subscribers\");\nvar socket_io_1 = require(\"./socket-io\");\nvar bindMessageHandler = function (webSocketInstance, url) {\n  webSocketInstance.onmessage = function (message) {\n    (0, manage_subscribers_1.getSubscribers)(url).forEach(function (subscriber) {\n      if (subscriber.optionsRef.current.onMessage) {\n        subscriber.optionsRef.current.onMessage(message);\n      }\n      if (typeof subscriber.optionsRef.current.filter === 'function' && subscriber.optionsRef.current.filter(message) !== true) {\n        return;\n      }\n      subscriber.setLastMessage(message);\n    });\n  };\n};\nvar bindOpenHandler = function (webSocketInstance, url) {\n  webSocketInstance.onopen = function (event) {\n    (0, manage_subscribers_1.getSubscribers)(url).forEach(function (subscriber) {\n      subscriber.reconnectCount.current = 0;\n      if (subscriber.optionsRef.current.onOpen) {\n        subscriber.optionsRef.current.onOpen(event);\n      }\n      subscriber.setReadyState(constants_1.ReadyState.OPEN);\n    });\n  };\n};\nvar bindCloseHandler = function (webSocketInstance, url) {\n  if (webSocketInstance instanceof WebSocket) {\n    webSocketInstance.onclose = function (event) {\n      (0, manage_subscribers_1.getSubscribers)(url).forEach(function (subscriber) {\n        if (subscriber.optionsRef.current.onClose) {\n          subscriber.optionsRef.current.onClose(event);\n        }\n        subscriber.setReadyState(constants_1.ReadyState.CLOSED);\n      });\n      delete globals_1.sharedWebSockets[url];\n      (0, manage_subscribers_1.getSubscribers)(url).forEach(function (subscriber) {\n        var _a, _b;\n        if (subscriber.optionsRef.current.shouldReconnect && subscriber.optionsRef.current.shouldReconnect(event)) {\n          var reconnectAttempts = (_a = subscriber.optionsRef.current.reconnectAttempts) !== null && _a !== void 0 ? _a : constants_1.DEFAULT_RECONNECT_LIMIT;\n          if (subscriber.reconnectCount.current < reconnectAttempts) {\n            setTimeout(function () {\n              subscriber.reconnectCount.current++;\n              subscriber.reconnect.current();\n            }, (_b = subscriber.optionsRef.current.reconnectInterval) !== null && _b !== void 0 ? _b : constants_1.DEFAULT_RECONNECT_INTERVAL_MS);\n          } else {\n            subscriber.optionsRef.current.onReconnectStop && subscriber.optionsRef.current.onReconnectStop(subscriber.optionsRef.current.reconnectAttempts);\n            console.warn(\"Max reconnect attempts of \".concat(reconnectAttempts, \" exceeded\"));\n          }\n        }\n      });\n    };\n  }\n};\nvar bindErrorHandler = function (webSocketInstance, url) {\n  webSocketInstance.onerror = function (error) {\n    (0, manage_subscribers_1.getSubscribers)(url).forEach(function (subscriber) {\n      if (subscriber.optionsRef.current.onError) {\n        subscriber.optionsRef.current.onError(error);\n      }\n      if (constants_1.isEventSourceSupported && webSocketInstance instanceof EventSource) {\n        subscriber.optionsRef.current.onClose && subscriber.optionsRef.current.onClose(__assign(__assign({}, error), {\n          code: 1006,\n          reason: \"An error occurred with the EventSource: \".concat(error),\n          wasClean: false\n        }));\n        subscriber.setReadyState(constants_1.ReadyState.CLOSED);\n      }\n    });\n    if (constants_1.isEventSourceSupported && webSocketInstance instanceof EventSource) {\n      webSocketInstance.close();\n    }\n  };\n};\nvar attachSharedListeners = function (webSocketInstance, url, optionsRef, sendMessage) {\n  var interval;\n  if (optionsRef.current.fromSocketIO) {\n    interval = (0, socket_io_1.setUpSocketIOPing)(sendMessage);\n  }\n  bindMessageHandler(webSocketInstance, url);\n  bindCloseHandler(webSocketInstance, url);\n  bindOpenHandler(webSocketInstance, url);\n  bindErrorHandler(webSocketInstance, url);\n  return function () {\n    if (interval) clearInterval(interval);\n  };\n};\nexports.attachSharedListeners = attachSharedListeners;","map":{"version":3,"mappings":"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","names":["bindMessageHandler","webSocketInstance","url","onmessage","message","forEach","subscriber","optionsRef","current","onMessage","filter","setLastMessage","bindOpenHandler","onopen","event","reconnectCount","onOpen","setReadyState","constants_1","OPEN","bindCloseHandler","WebSocket","onclose","onClose","CLOSED","globals_1","shouldReconnect","reconnectAttempts","setTimeout","reconnect","reconnectInterval","onReconnectStop","console","warn","bindErrorHandler","onerror","error","onError","EventSource","code","reason","wasClean","close","attachSharedListeners","sendMessage","interval","fromSocketIO","clearInterval","exports"],"sources":["/Users/alanschmidt/Work/coin-routes/node_modules/react-use-websocket/src/lib/attach-shared-listeners.ts"],"sourcesContent":["import { sharedWebSockets } from './globals';\nimport { DEFAULT_RECONNECT_LIMIT, DEFAULT_RECONNECT_INTERVAL_MS, ReadyState, isEventSourceSupported } from './constants';\nimport { getSubscribers } from './manage-subscribers';\nimport { MutableRefObject } from 'react';\nimport { Options, SendMessage, WebSocketLike } from './types';\nimport { setUpSocketIOPing } from './socket-io';\n\nconst bindMessageHandler = (\n  webSocketInstance: WebSocketLike,\n  url: string,\n) => {\n  webSocketInstance.onmessage = (message: WebSocketEventMap['message']) => {\n    getSubscribers(url).forEach(subscriber => {\n      if (subscriber.optionsRef.current.onMessage) {\n        subscriber.optionsRef.current.onMessage(message);\n      }\n\n      if (\n        typeof subscriber.optionsRef.current.filter === 'function' &&\n        subscriber.optionsRef.current.filter(message) !== true\n      ) {\n        return;\n      }\n\n      subscriber.setLastMessage(message);\n    });\n  };\n};\n\nconst bindOpenHandler = (\n  webSocketInstance: WebSocketLike,\n  url: string,\n) => {\n  webSocketInstance.onopen = (event: WebSocketEventMap['open']) => {\n    getSubscribers(url).forEach(subscriber => {\n      subscriber.reconnectCount.current = 0;\n      if (subscriber.optionsRef.current.onOpen) {\n        subscriber.optionsRef.current.onOpen(event);\n      }\n\n      subscriber.setReadyState(ReadyState.OPEN);\n    });\n  };\n};\n\nconst bindCloseHandler = (\n  webSocketInstance: WebSocketLike,\n  url: string,\n) => {\n  if (webSocketInstance instanceof WebSocket) {\n    webSocketInstance.onclose = (event: WebSocketEventMap['close']) => {\n      getSubscribers(url).forEach(subscriber => {\n        if (subscriber.optionsRef.current.onClose) {\n          subscriber.optionsRef.current.onClose(event);\n        }\n  \n        subscriber.setReadyState(ReadyState.CLOSED);\n      });\n      \n      delete sharedWebSockets[url];\n  \n      getSubscribers(url).forEach(subscriber => {\n        if (\n          subscriber.optionsRef.current.shouldReconnect &&\n          subscriber.optionsRef.current.shouldReconnect(event)\n        ) {\n          const reconnectAttempts = subscriber.optionsRef.current.reconnectAttempts ?? DEFAULT_RECONNECT_LIMIT;\n          if (subscriber.reconnectCount.current < reconnectAttempts) {\n            setTimeout(() => {\n              subscriber.reconnectCount.current++;\n              subscriber.reconnect.current();\n            }, subscriber.optionsRef.current.reconnectInterval ?? DEFAULT_RECONNECT_INTERVAL_MS);\n          } else {\n            subscriber.optionsRef.current.onReconnectStop && subscriber.optionsRef.current.onReconnectStop(subscriber.optionsRef.current.reconnectAttempts as number);\n            console.warn(`Max reconnect attempts of ${reconnectAttempts} exceeded`);\n          }\n        }\n      });\n    };\n  }\n};\n\nconst bindErrorHandler = (\n  webSocketInstance: WebSocketLike,\n  url: string,\n) => {\n  webSocketInstance.onerror = (error: WebSocketEventMap['error']) => {\n    getSubscribers(url).forEach(subscriber => {\n      if (subscriber.optionsRef.current.onError) {\n        subscriber.optionsRef.current.onError(error);\n      }\n      if (isEventSourceSupported && webSocketInstance instanceof EventSource) {\n        subscriber.optionsRef.current.onClose && subscriber.optionsRef.current.onClose({\n          ...error,\n          code: 1006,\n          reason: `An error occurred with the EventSource: ${error}`,\n          wasClean: false,\n        });\n  \n        subscriber.setReadyState(ReadyState.CLOSED);\n      }\n    });\n    if (isEventSourceSupported && webSocketInstance instanceof EventSource) {\n      webSocketInstance.close();\n    }\n  };\n};\n\nexport const attachSharedListeners = (\n  webSocketInstance: WebSocketLike,\n  url: string,\n  optionsRef: MutableRefObject<Options>,\n  sendMessage: SendMessage,\n) => {\n  let interval: number;\n\n  if (optionsRef.current.fromSocketIO) {\n    interval = setUpSocketIOPing(sendMessage);\n  }\n\n  bindMessageHandler(webSocketInstance, url);\n  bindCloseHandler(webSocketInstance, url);\n  bindOpenHandler(webSocketInstance, url);\n  bindErrorHandler(webSocketInstance, url);\n\n  return () => {\n    if (interval) clearInterval(interval);\n  };\n};\n"]},"metadata":{},"sourceType":"script","externalDependencies":[]}